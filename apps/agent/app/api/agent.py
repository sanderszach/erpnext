"""
Agent API endpoints.

This module exposes endpoints for interacting with the LangGraph agent.
"""

import uuid
from typing import Any

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field

from app.agent.graph import run_agent

router = APIRouter()


class AgentRequest(BaseModel):
    """
    Request body for the agent run endpoint.

    Attributes:
        input: The user input to process.
        session_id: Optional session identifier for conversation continuity.
    """

    input: str = Field(..., min_length=1, description="The user input to process")
    session_id: str | None = Field(
        default=None,
        description="Optional session ID for conversation continuity",
    )


class AgentResponse(BaseModel):
    """
    Response from the agent run endpoint.

    Attributes:
        session_id: The session identifier (generated if not provided).
        input: The original user input.
        plan: The plan generated by the planner (if any).
        output: The final output from the agent.
        metadata: Additional metadata about the run.
    """

    session_id: str
    input: str
    plan: str | None = None
    output: str
    metadata: dict[str, Any] = Field(default_factory=dict)


@router.post("/run", response_model=AgentResponse)
async def run_agent_endpoint(request: AgentRequest) -> AgentResponse:
    """
    Execute the agent with the given input.

    This endpoint accepts user input and runs it through the LangGraph
    agent pipeline (planner â†’ executor).

    Args:
        request: The agent request containing input and optional session ID.

    Returns:
        The agent response with the processed output.

    Raises:
        HTTPException: If agent execution fails.
    """
    # Generate session ID if not provided
    session_id = request.session_id or str(uuid.uuid4())

    try:
        # Run the agent graph
        result = await run_agent(
            input_text=request.input,
            session_id=session_id,
        )

        return AgentResponse(
            session_id=session_id,
            input=request.input,
            plan=result.get("plan"),
            output=result.get("output", ""),
            metadata=result.get("metadata", {}),
        )

    except Exception as e:
        # Log the error in production
        raise HTTPException(
            status_code=500,
            detail=f"Agent execution failed: {str(e)}",
        ) from e


@router.get("/status")
async def agent_status() -> dict[str, str]:
    """
    Get the agent status.

    Returns:
        A dictionary with the agent status.
    """
    return {
        "status": "ready",
        "message": "Agent control plane is operational",
    }

