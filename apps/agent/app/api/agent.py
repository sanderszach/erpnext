"""
Agent API endpoints.

This module exposes endpoints for interacting with the LangGraph agent.
"""

import uuid
from typing import Any

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field

from app.agent.chat import chat_with_agent, clear_session, get_session_history
from app.agent.graph import run_agent

router = APIRouter()


class AgentRequest(BaseModel):
    """
    Request body for the agent run endpoint.

    Attributes:
        input: The user input to process.
        session_id: Optional session identifier for conversation continuity.
    """

    input: str = Field(..., min_length=1, description="The user input to process")
    session_id: str | None = Field(
        default=None,
        description="Optional session ID for conversation continuity",
    )


class AgentResponse(BaseModel):
    """
    Response from the agent run endpoint.

    Attributes:
        session_id: The session identifier (generated if not provided).
        input: The original user input.
        plan: The plan generated by the planner (if any).
        output: The final output from the agent.
        metadata: Additional metadata about the run.
    """

    session_id: str
    input: str
    plan: str | None = None
    output: str
    metadata: dict[str, Any] = Field(default_factory=dict)


@router.post("/run", response_model=AgentResponse)
async def run_agent_endpoint(request: AgentRequest) -> AgentResponse:
    """
    Execute the agent with the given input.

    This endpoint accepts user input and runs it through the LangGraph
    agent pipeline (planner â†’ executor).

    Args:
        request: The agent request containing input and optional session ID.

    Returns:
        The agent response with the processed output.

    Raises:
        HTTPException: If agent execution fails.
    """
    # Generate session ID if not provided
    session_id = request.session_id or str(uuid.uuid4())

    try:
        # Run the agent graph
        result = await run_agent(
            input_text=request.input,
            session_id=session_id,
        )

        return AgentResponse(
            session_id=session_id,
            input=request.input,
            plan=result.get("plan"),
            output=result.get("output", ""),
            metadata=result.get("metadata", {}),
        )

    except Exception as e:
        # Log the error in production
        raise HTTPException(
            status_code=500,
            detail=f"Agent execution failed: {str(e)}",
        ) from e


@router.get("/status")
async def agent_status() -> dict[str, str]:
    """
    Get the agent status.

    Returns:
        A dictionary with the agent status.
    """
    return {
        "status": "ready",
        "message": "Agent control plane is operational",
    }


# ============================================================================
# Chat Endpoint - Interactive conversation with ERPNext tools
# ============================================================================


class ChatMessage(BaseModel):
    """A single message in the conversation."""

    role: str = Field(..., description="Message role: 'user' or 'assistant'")
    content: str = Field(..., description="Message content")


class ChatRequest(BaseModel):
    """
    Request body for the chat endpoint.

    Attributes:
        message: The user's message.
        conversation_history: Optional previous messages for context.
        session_id: Optional session identifier.
    """

    message: str = Field(..., min_length=1, description="The user's message")
    conversation_history: list[ChatMessage] | None = Field(
        default=None,
        description="Previous messages in the conversation",
    )
    session_id: str | None = Field(
        default=None,
        description="Optional session ID for tracking",
    )


class ToolCallInfo(BaseModel):
    """Information about a tool call made by the agent."""

    tool: str
    args: dict[str, Any]
    result_preview: str


class ChatResponse(BaseModel):
    """
    Response from the chat endpoint.

    Attributes:
        session_id: Session identifier.
        message: The user's original message.
        response: The agent's response.
        tool_calls: List of tools called during processing.
        error: Whether an error occurred.
    """

    session_id: str
    message: str
    response: str
    tool_calls: list[ToolCallInfo] = Field(default_factory=list)
    error: bool = False


@router.post("/chat", response_model=ChatResponse)
async def chat_endpoint(request: ChatRequest) -> ChatResponse:
    """
    Chat with the ERPNext agent.

    This endpoint allows conversational interaction with an AI agent that
    has access to ERPNext tools. The agent can:
    - Query documents and doctypes
    - Create and update documents
    - Run reports
    - Answer questions about your ERPNext data

    Args:
        request: The chat request with message and optional history.

    Returns:
        The agent's response with any tool calls made.

    Example:
        ```
        POST /agent/chat
        {
            "message": "List all customers"
        }
        ```
    """
    session_id = request.session_id or str(uuid.uuid4())

    try:
        # Convert history to dict format (only used if no session_id for memory)
        history = None
        if request.conversation_history and not request.session_id:
            history = [
                {"role": msg.role, "content": msg.content}
                for msg in request.conversation_history
            ]

        # Call the chat agent with session-based memory
        result = await chat_with_agent(
            message=request.message,
            session_id=session_id,
            conversation_history=history,
        )

        return ChatResponse(
            session_id=session_id,
            message=request.message,
            response=result.get("response", ""),
            tool_calls=[
                ToolCallInfo(**tc) for tc in result.get("tool_calls", [])
            ],
            error=result.get("error", False),
        )

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Chat failed: {str(e)}",
        ) from e


# ============================================================================
# Session Management Endpoints
# ============================================================================


class SessionHistoryResponse(BaseModel):
    """Response containing session conversation history."""

    session_id: str
    messages: list[ChatMessage]
    message_count: int


@router.get("/sessions/{session_id}/history", response_model=SessionHistoryResponse)
async def get_history_endpoint(session_id: str) -> SessionHistoryResponse:
    """
    Get conversation history for a session.

    Args:
        session_id: The session identifier.

    Returns:
        The conversation history.
    """
    history = await get_session_history(session_id)
    return SessionHistoryResponse(
        session_id=session_id,
        messages=[ChatMessage(role=m["role"], content=m["content"]) for m in history],
        message_count=len(history),
    )


@router.delete("/sessions/{session_id}")
async def clear_session_endpoint(session_id: str) -> dict[str, Any]:
    """
    Clear conversation history for a session.

    Args:
        session_id: The session to clear.

    Returns:
        Confirmation of deletion.
    """
    deleted = await clear_session(session_id)
    return {
        "session_id": session_id,
        "deleted": deleted,
        "message": "Session cleared" if deleted else "Session not found",
    }

